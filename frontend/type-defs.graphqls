schema {
  query: Query
  mutation: Mutation
}

interface Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  locale: Locale!
  name: String
  resources: [GetHttpsResource!]!
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid!
  warnings: [String!]!
}

"The node interface is implemented by entities that have a global unique identifier."
interface Node {
  id: ID!
}

interface Reference {
  abstract: String
  section: String
  title: String
}

type Address {
  formatted: String!
}

type AppliedMethod {
  arguments: [NamedMethodArgument!]!
  methodId: Uuid!
  sources: [NamedMethodSource!]!
}

type CalorimetricData implements Node & Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  gValues: [Float!]!
  id: ID!
  locale: Locale!
  name: String
  resources: [GetHttpsResource!]! @cost(weight: "10")
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid! @cost(weight: "10")
  uValues: [Float!]!
  warnings: [String!]!
}

"A connection to a list of items."
type CalorimetricDataConnection {
  "A list of edges."
  edges: [CalorimetricDataEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type CalorimetricDataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: CalorimetricData!
}

type CielabColor {
  aStar: Float!
  bStar: Float!
  lStar: Float!
}

type CreateCalorimetricDataError {
  code: CreateCalorimetricDataErrorCode!
  message: String!
  path: [String!]!
}

type CreateCalorimetricDataPayload {
  calorimetricData: CalorimetricData
  errors: [CreateCalorimetricDataError!]
  query: Query!
}

type CreateGeometricDataError {
  code: CreateGeometricDataErrorCode!
  message: String!
  path: [String!]!
}

type CreateGeometricDataPayload {
  errors: [CreateGeometricDataError!]
  geometricData: GeometricData
  query: Query!
}

type CreateGetHttpsResourceError {
  code: CreateGetHttpsResourceErrorCode!
  message: String!
  path: [String!]!
}

type CreateGetHttpsResourcePayload {
  errors: [CreateGetHttpsResourceError!]
  getHttpsResource: GetHttpsResource
  query: Query!
}

type CreateHygrothermalDataError {
  code: CreateHygrothermalDataErrorCode!
  message: String!
  path: [String!]!
}

type CreateHygrothermalDataPayload {
  errors: [CreateHygrothermalDataError!]
  hygrothermalData: HygrothermalData
  query: Query!
}

type CreateOpticalDataError {
  code: CreateOpticalDataErrorCode!
  message: String!
  path: [String!]!
}

type CreateOpticalDataPayload {
  errors: [CreateOpticalDataError!]
  opticalData: OpticalData
  query: Query!
}

type CreatePhotovoltaicDataError {
  code: CreatePhotovoltaicDataErrorCode!
  message: String!
  path: [String!]!
}

type CreatePhotovoltaicDataPayload {
  errors: [CreatePhotovoltaicDataError!]
  photovoltaicData: PhotovoltaicData
  query: Query!
}

type CrossDatabaseDataReference {
  databaseId: Uuid!
  dataId: Uuid!
  dataKind: DataKind!
  dataTimestamp: DateTime!
}

type DataApproval {
  approverId: Uuid!
  keyFingerprint: String!
  query: String!
  response: String!
  signature: String!
  statement: Reference
  timestamp: DateTime!
}

"A connection to a list of items."
type DataConnection {
  "A list of edges."
  edges: [DataEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type DataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: Data!
}

type Database {
  canCurrentUserUpdateNode: Boolean!
  canCurrentUserVerifyNode: Boolean!
  description: String!
  locator: Url!
  name: String!
  uuid: Uuid!
  verificationCode: String!
  verificationState: DatabaseVerificationState!
}

type FileMetaInformation {
  dataFormatId: Uuid!
  path: [String!]!
}

type GeometricData implements Node & Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  id: ID!
  locale: Locale!
  name: String
  resources: [GetHttpsResource!]! @cost(weight: "10")
  resourceTree: GetHttpsResourceTree!
  thicknesses: [Float!]!
  timestamp: DateTime!
  uuid: Uuid! @cost(weight: "10")
  warnings: [String!]!
}

"A connection to a list of items."
type GeometricDataConnection {
  "A list of edges."
  edges: [GeometricDataEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type GeometricDataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GeometricData!
}

type GetHttpsResource implements Node {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethod
  archivedFilesMetaInformation: [FileMetaInformation!]!
  children: [GetHttpsResource!]! @cost(weight: "10")
  data: Data @cost(weight: "10")
  dataFormatId: Uuid!
  description: String!
  hashValue: String!
  id: ID!
  locator: Url!
  parent: GetHttpsResource @cost(weight: "10")
  uuid: Uuid! @cost(weight: "10")
}

"A connection to a list of items."
type GetHttpsResourceConnection {
  "A list of edges."
  edges: [GetHttpsResourceEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type GetHttpsResourceEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: GetHttpsResource!
}

type GetHttpsResourceTree {
  nonRootVertices: [GetHttpsResourceTreeNonRootVertex!]! @cost(weight: "10")
  root: GetHttpsResourceTreeRoot! @cost(weight: "10")
}

type GetHttpsResourceTreeNonRootVertex {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethod!
  parentId: ID!
  value: GetHttpsResource!
  vertexId: ID!
}

type GetHttpsResourceTreeRoot {
  value: GetHttpsResource!
  vertexId: ID!
}

type HygrothermalData implements Node & Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  id: ID!
  locale: Locale!
  name: String
  resources: [GetHttpsResource!]! @cost(weight: "10")
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid! @cost(weight: "10")
  warnings: [String!]!
}

"A connection to a list of items."
type HygrothermalDataConnection {
  "A list of edges."
  edges: [HygrothermalDataEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type HygrothermalDataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: HygrothermalData!
}

type Mutation {
  createCalorimetricData(input: CreateCalorimetricDataInput!): CreateCalorimetricDataPayload! @cost(weight: "10")
  createGeometricData(input: CreateGeometricDataInput!): CreateGeometricDataPayload! @cost(weight: "10")
  createGetHttpsResource(input: CreateGetHttpsResourceInput!): CreateGetHttpsResourcePayload! @cost(weight: "10")
  createHygrothermalData(input: CreateHygrothermalDataInput!): CreateHygrothermalDataPayload! @cost(weight: "10")
  createOpticalData(input: CreateOpticalDataInput!): CreateOpticalDataPayload! @cost(weight: "10")
  createPhotovoltaicData(input: CreatePhotovoltaicDataInput!): CreatePhotovoltaicDataPayload! @cost(weight: "10")
  updateDatabase(input: UpdateDatabaseInput!): UpdateDatabasePayload! @cost(weight: "10")
}

type NamedMethodArgument {
  name: String!
  value: Any! @cost(weight: "10")
}

type NamedMethodSource {
  name: String!
  value: CrossDatabaseDataReference!
}

type Numeration {
  mainNumber: String!
  prefix: String
  suffix: String
}

type OpenEndedDateTimeRange {
  from: DateTime @cost(weight: "10")
  until: DateTime @cost(weight: "10")
}

type OpticalData implements Node & Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  cielabColors: [CielabColor!]!
  colorRenderingIndices: [Float!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  id: ID!
  infraredEmittances: [Float!]!
  locale: Locale!
  name: String
  nearnormalHemisphericalSolarReflectances: [Float!]!
  nearnormalHemisphericalSolarTransmittances: [Float!]!
  nearnormalHemisphericalVisibleReflectances: [Float!]!
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
  resources: [GetHttpsResource!]! @cost(weight: "10")
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid! @cost(weight: "10")
  warnings: [String!]!
}

"A connection to a list of items."
type OpticalDataConnection {
  "A list of edges."
  edges: [OpticalDataEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type OpticalDataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: OpticalData!
}

"Information about pagination in a connection."
type PageInfo {
  "When paginating forwards, the cursor to continue."
  endCursor: String
  "Indicates whether more edges exist following the set defined by the clients arguments."
  hasNextPage: Boolean!
  "Indicates whether more edges exist prior the set defined by the clients arguments."
  hasPreviousPage: Boolean!
  "When paginating backwards, the cursor to continue."
  startCursor: String
}

type PhotovoltaicData implements Node & Data {
  appliedMethod: AppliedMethod!
  approvals: [DataApproval!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  id: ID!
  locale: Locale!
  name: String
  resources: [GetHttpsResource!]! @cost(weight: "10")
  resourceTree: GetHttpsResourceTree!
  timestamp: DateTime!
  uuid: Uuid! @cost(weight: "10")
  warnings: [String!]!
}

"A connection to a list of items."
type PhotovoltaicDataConnection {
  "A list of edges."
  edges: [PhotovoltaicDataEdge!]
  "Information to aid in pagination."
  pageInfo: PageInfo!
  "Identifies the total count of items in the connection."
  totalCount: Int! @cost(weight: "10")
}

"An edge in a connection."
type PhotovoltaicDataEdge {
  "A cursor for use in pagination."
  cursor: String!
  "The item at the end of the edge."
  node: PhotovoltaicData!
}

type Publication implements Reference {
  abstract: String
  "The website arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: String
  authors: [String!]
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: String
  "Referenced section"
  section: String
  title: String
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: String
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: Url
}

type Query {
  allCalorimetricData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [CalorimetricDataSortInput!] @cost(weight: "10") timestamp: DateTime where: CalorimetricDataPropositionInput @cost(weight: "10")): CalorimetricDataConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  allData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [IDataSortInput!] @cost(weight: "10") timestamp: DateTime where: DataPropositionInput @cost(weight: "10")): DataConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  allGeometricData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [GeometricDataSortInput!] @cost(weight: "10") timestamp: DateTime where: GeometricDataPropositionInput @cost(weight: "10")): GeometricDataConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  allHygrothermalData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [HygrothermalDataSortInput!] @cost(weight: "10") timestamp: DateTime where: HygrothermalDataPropositionInput @cost(weight: "10")): HygrothermalDataConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  allOpticalData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [OpticalDataSortInput!] @cost(weight: "10") timestamp: DateTime where: OpticalDataPropositionInput @cost(weight: "10")): OpticalDataConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  allPhotovoltaicData("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int locale: Locale order: [PhotovoltaicDataSortInput!] @cost(weight: "10") timestamp: DateTime where: PhotovoltaicDataPropositionInput @cost(weight: "10")): PhotovoltaicDataConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  calorimetricData(id: Uuid! locale: Locale timestamp: DateTime): CalorimetricData @cost(weight: "10")
  currentUser: User @cost(weight: "10")
  currentUserInfo: UserInfo @cost(weight: "10")
  data(id: Uuid! locale: Locale timestamp: DateTime): Data @cost(weight: "10")
  database: Database! @cost(weight: "10")
  geometricData(id: Uuid! locale: Locale timestamp: DateTime): GeometricData @cost(weight: "10")
  getHttpsResource(id: Uuid!): GetHttpsResource @cost(weight: "10")
  getHttpsResources("Returns the elements in the list that come after the specified cursor." after: String "Returns the elements in the list that come before the specified cursor." before: String "Returns the first _n_ elements from the list." first: Int "Returns the last _n_ elements from the list." last: Int order: [GetHttpsResourceSortInput!] @cost(weight: "10") where: GetHttpsResourcePropositionInput @cost(weight: "10")): GetHttpsResourceConnection @listSize(assumedSize: 2147483646, slicingArguments: [ "first", "last" ], sizedFields: [ "edges", "nodes" ]) @cost(weight: "10")
  hygrothermalData(id: Uuid! locale: Locale timestamp: DateTime): HygrothermalData @cost(weight: "10")
  "Fetches an object given its ID."
  node("ID of the object." id: ID!): Node @cost(weight: "10")
  "Lookup nodes by a list of IDs."
  nodes("The list of node IDs." ids: [ID!]!): [Node]! @cost(weight: "10")
  opticalData(id: Uuid! locale: Locale timestamp: DateTime): OpticalData @cost(weight: "10")
  photovoltaicData(id: Uuid! locale: Locale timestamp: DateTime): PhotovoltaicData @cost(weight: "10")
  verificationCode: String!
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
type Standard implements Reference {
  abstract: String
  locator: Url
  numeration: Numeration!
  "The section of the standard to which the reference refers to."
  section: String
  standardizers: [Standardizer!]!
  title: String
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: Int
}

type ToTreeVertexAppliedConversionMethod {
  arguments: [NamedMethodArgument!]!
  methodId: Uuid!
  sourceName: String!
}

type UpdateDatabaseError {
  code: UpdateDatabaseErrorCode!
  message: String!
  path: [String!]!
}

type UpdateDatabasePayload {
  database: Database
  errors: [UpdateDatabaseError!]
  query: Query!
}

type User implements Node {
  id: ID!
  name: String!
  subject: String!
  uuid: Uuid! @cost(weight: "10")
}

type UserInfo {
  address: Address
  email: String!
  emailVerified: Boolean!
  name: String!
  phoneNumber: String
  phoneNumberVerified: Boolean!
  roles: [String!]
  sub: String!
  website: String
}

input AppliedMethodInput {
  arguments: [NamedMethodArgumentInput!]!
  methodId: Uuid!
  sources: [NamedMethodSourceInput!]!
}

input AppliedMethodPropositionInput {
  and: [AppliedMethodPropositionInput!]
  or: [AppliedMethodPropositionInput!]
  methodId: UuidPropositionInput
  arguments: ListNamedMethodArgumentFilterTypePropositionInput
  sources: ListFilterInputTypeOfNamedMethodSourcePropositionInput
}

input AppliedMethodSortInput {
  methodId: SortEnumType @cost(weight: "10")
}

input BooleanPropositionInput {
  equalTo: Boolean @cost(weight: "10")
  notEqualTo: Boolean @cost(weight: "10")
}

input CalorimetricDataPropositionInput {
  and: [CalorimetricDataPropositionInput!]
  or: [CalorimetricDataPropositionInput!]
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
  id: UuidPropositionInput
  gValues: FloatsPropositionInput
  uValues: FloatsPropositionInput
}

input CalorimetricDataSortInput {
  locale: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  componentId: SortEnumType @cost(weight: "10")
  creatorId: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
  appliedMethod: AppliedMethodSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
}

input CielabColorInput {
  aStar: Float!
  bStar: Float!
  lStar: Float!
}

input CielabColorPropositionInput {
  and: [CielabColorPropositionInput!]
  or: [CielabColorPropositionInput!]
  lStar: FloatPropositionInput
  aStar: FloatPropositionInput
  bStar: FloatPropositionInput
}

input CreateCalorimetricDataInput {
  accessToken: String!
  appliedMethod: AppliedMethodInput!
  approvals: [DataApprovalInput!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  gValues: [Float!]!
  locale: String!
  name: String
  rootResource: RootGetHttpsResourceInput!
  uValues: [Float!]!
  warnings: [String!]!
}

input CreateGeometricDataInput {
  accessToken: String!
  appliedMethod: AppliedMethodInput!
  approvals: [DataApprovalInput!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  locale: String!
  name: String
  rootResource: RootGetHttpsResourceInput!
  thicknesses: [Float!]!
  warnings: [String!]!
}

input CreateGetHttpsResourceInput {
  accessToken: String!
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodInput
  archivedFilesMetaInformation: [FileMetaInformationInput!]!
  dataFormatId: Uuid!
  dataId: Uuid!
  dataKind: DataKind!
  description: String!
  hashValue: String!
  parentId: Uuid
}

input CreateHygrothermalDataInput {
  accessToken: String!
  appliedMethod: AppliedMethodInput!
  approvals: [DataApprovalInput!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  locale: String!
  name: String
  rootResource: RootGetHttpsResourceInput!
  warnings: [String!]!
}

input CreateNumerationInput {
  mainNumber: String!
  prefix: String
  suffix: String
}

input CreateOpticalDataInput {
  accessToken: String!
  appliedMethod: AppliedMethodInput!
  approvals: [DataApprovalInput!]!
  cielabColors: [CielabColorInput!]!
  colorRenderingIndices: [Float!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  infraredEmittances: [Float!]!
  locale: String!
  name: String
  nearnormalHemisphericalSolarReflectances: [Float!]!
  nearnormalHemisphericalSolarTransmittances: [Float!]!
  nearnormalHemisphericalVisibleReflectances: [Float!]!
  nearnormalHemisphericalVisibleTransmittances: [Float!]!
  rootResource: RootGetHttpsResourceInput!
  warnings: [String!]!
}

input CreatePhotovoltaicDataInput {
  accessToken: String!
  appliedMethod: AppliedMethodInput!
  approvals: [DataApprovalInput!]!
  componentId: Uuid!
  createdAt: DateTime!
  creatorId: Uuid!
  description: String
  locale: String!
  name: String
  rootResource: RootGetHttpsResourceInput!
  warnings: [String!]!
}

input CreatePublicationInput {
  abstract: String
  arXiv: String
  authors: [String!]
  doi: String
  section: String
  title: String
  urn: String
  webAddress: Url
}

input CreateStandardInput {
  abstract: String
  locator: Url
  numeration: CreateNumerationInput!
  section: String
  standardizers: [Standardizer!]!
  title: String
  year: Int
}

input CrossDatabaseDataReferenceInput {
  databaseId: Uuid!
  dataId: Uuid!
  dataKind: DataKind!
  dataTimestamp: DateTime!
}

input CrossDatabaseDataReferencePropositionInput {
  and: [CrossDatabaseDataReferencePropositionInput!]
  or: [CrossDatabaseDataReferencePropositionInput!]
  dataId: UuidPropositionInput
  dataTimestamp: DateTimePropositionInput
  dataKind: DataKindPropositionInput
  databaseId: UuidPropositionInput
}

input DataApprovalInput {
  approverId: Uuid!
  keyFingerprint: String!
  publication: CreatePublicationInput
  query: String!
  response: String!
  signature: String!
  standard: CreateStandardInput
  timestamp: DateTime!
}

input DataApprovalPropositionInput {
  and: [DataApprovalPropositionInput!]
  or: [DataApprovalPropositionInput!]
  approverId: UuidPropositionInput
  timestamp: DateTimePropositionInput
  signature: StringPropositionInput
  keyFingerprint: StringPropositionInput
  query: StringPropositionInput
  response: StringPropositionInput
  publication: PublicationPropositionInput
  standard: StandardPropositionInput
  statement: IReferencePropositionInput
}

input DataKindPropositionInput {
  equalTo: DataKind @cost(weight: "10")
  notEqualTo: DataKind @cost(weight: "10")
  in: [DataKind!] @cost(weight: "10")
  notIn: [DataKind!] @cost(weight: "10")
}

input DataPropositionInput {
  and: [DataPropositionInput!]
  or: [DataPropositionInput!]
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
}

input DateTimePropositionInput {
  equalTo: DateTime @cost(weight: "10")
  notEqualTo: DateTime @cost(weight: "10")
  in: [DateTime!] @cost(weight: "10")
  notIn: [DateTime!] @cost(weight: "10")
  greaterThan: DateTime @cost(weight: "10")
  notGreaterThan: DateTime @cost(weight: "10")
  greaterThanOrEqualTo: DateTime @cost(weight: "10")
  notGreaterThanOrEqualTo: DateTime @cost(weight: "10")
  lessThan: DateTime @cost(weight: "10")
  notLessThan: DateTime @cost(weight: "10")
  lessThanOrEqualTo: DateTime @cost(weight: "10")
  notLessThanOrEqualTo: DateTime @cost(weight: "10")
}

input FileMetaInformationInput {
  dataFormatId: Uuid!
  path: [String!]!
}

input FileMetaInformationPropositionInput {
  and: [FileMetaInformationPropositionInput!]
  or: [FileMetaInformationPropositionInput!]
  path: StringsPropositionInput
  dataFormatId: UuidPropositionInput
}

input FloatPropositionInput {
  equalTo: Float @cost(weight: "10")
  notEqualTo: Float @cost(weight: "10")
  in: [Float!] @cost(weight: "10")
  notIn: [Float!] @cost(weight: "10")
  greaterThan: Float @cost(weight: "10")
  notGreaterThan: Float @cost(weight: "10")
  greaterThanOrEqualTo: Float @cost(weight: "10")
  notGreaterThanOrEqualTo: Float @cost(weight: "10")
  lessThan: Float @cost(weight: "10")
  notLessThan: Float @cost(weight: "10")
  lessThanOrEqualTo: Float @cost(weight: "10")
  notLessThanOrEqualTo: Float @cost(weight: "10")
}

input FloatsPropositionInput {
  all: FloatPropositionInput @cost(weight: "10")
  none: FloatPropositionInput @cost(weight: "10")
  some: FloatPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input GeometricDataPropositionInput {
  and: [GeometricDataPropositionInput!]
  or: [GeometricDataPropositionInput!]
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
  id: UuidPropositionInput
  thicknesses: FloatsPropositionInput
}

input GeometricDataSortInput {
  locale: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  componentId: SortEnumType @cost(weight: "10")
  creatorId: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
  appliedMethod: AppliedMethodSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
}

input GetHttpsResourcePropositionInput {
  and: [GetHttpsResourcePropositionInput!]
  or: [GetHttpsResourcePropositionInput!]
  id: UuidPropositionInput
  description: StringPropositionInput
  hashValue: StringPropositionInput
  dataFormatId: UuidPropositionInput
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodPropositionInput
  archivedFilesMetaInformation: ListFilterInputTypeOfFileMetaInformationPropositionInput
  data: DataPropositionInput
  parent: GetHttpsResourcePropositionInput
}

input GetHttpsResourceSortInput {
  id: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  hashValue: SortEnumType @cost(weight: "10")
  dataFormatId: SortEnumType @cost(weight: "10")
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodSortInput @cost(weight: "10")
  data: IDataSortInput @cost(weight: "10")
  parent: GetHttpsResourceSortInput @cost(weight: "10")
}

input HygrothermalDataPropositionInput {
  and: [HygrothermalDataPropositionInput!]
  or: [HygrothermalDataPropositionInput!]
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
  id: UuidPropositionInput
}

input HygrothermalDataSortInput {
  locale: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  componentId: SortEnumType @cost(weight: "10")
  creatorId: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
  appliedMethod: AppliedMethodSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
}

input IDataSortInput {
  locale: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  componentId: SortEnumType @cost(weight: "10")
  creatorId: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
  appliedMethod: AppliedMethodSortInput @cost(weight: "10")
}

input IReferencePropositionInput {
  and: [IReferencePropositionInput!]
  or: [IReferencePropositionInput!]
  title: StringPropositionInput
  abstract: StringPropositionInput
  section: StringPropositionInput
}

input Int32PropositionInput {
  equalTo: Int @cost(weight: "10")
  notEqualTo: Int @cost(weight: "10")
  in: [Int!] @cost(weight: "10")
  notIn: [Int!] @cost(weight: "10")
  greaterThan: Int @cost(weight: "10")
  notGreaterThan: Int @cost(weight: "10")
  greaterThanOrEqualTo: Int @cost(weight: "10")
  notGreaterThanOrEqualTo: Int @cost(weight: "10")
  lessThan: Int @cost(weight: "10")
  notLessThan: Int @cost(weight: "10")
  lessThanOrEqualTo: Int @cost(weight: "10")
  notLessThanOrEqualTo: Int @cost(weight: "10")
}

input ListFilterInputTypeOfCielabColorPropositionInput {
  all: CielabColorPropositionInput @cost(weight: "10")
  none: CielabColorPropositionInput @cost(weight: "10")
  some: CielabColorPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfDataApprovalPropositionInput {
  all: DataApprovalPropositionInput @cost(weight: "10")
  none: DataApprovalPropositionInput @cost(weight: "10")
  some: DataApprovalPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfFileMetaInformationPropositionInput {
  all: FileMetaInformationPropositionInput @cost(weight: "10")
  none: FileMetaInformationPropositionInput @cost(weight: "10")
  some: FileMetaInformationPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListFilterInputTypeOfNamedMethodSourcePropositionInput {
  all: NamedMethodSourcePropositionInput @cost(weight: "10")
  none: NamedMethodSourcePropositionInput @cost(weight: "10")
  some: NamedMethodSourcePropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListGetHttpsResourceFilterTypePropositionInput {
  all: GetHttpsResourcePropositionInput @cost(weight: "10")
  none: GetHttpsResourcePropositionInput @cost(weight: "10")
  some: GetHttpsResourcePropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListNamedMethodArgumentFilterTypePropositionInput {
  all: NamedMethodArgumentPropositionInput @cost(weight: "10")
  none: NamedMethodArgumentPropositionInput @cost(weight: "10")
  some: NamedMethodArgumentPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ListStandardizerPropositionInput {
  all: StandardizerPropositionInput @cost(weight: "10")
  none: StandardizerPropositionInput @cost(weight: "10")
  some: StandardizerPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input NamedMethodArgumentInput {
  name: String!
  value: Any!
}

input NamedMethodArgumentPropositionInput {
  and: [NamedMethodArgumentPropositionInput!]
  or: [NamedMethodArgumentPropositionInput!]
  name: StringPropositionInput
}

input NamedMethodSourceInput {
  name: String!
  value: CrossDatabaseDataReferenceInput!
}

input NamedMethodSourcePropositionInput {
  and: [NamedMethodSourcePropositionInput!]
  or: [NamedMethodSourcePropositionInput!]
  name: StringPropositionInput
  value: CrossDatabaseDataReferencePropositionInput
}

input NullableOfInt32PropositionInput {
  equalTo: Int @cost(weight: "10")
  notEqualTo: Int @cost(weight: "10")
  in: [Int] @cost(weight: "10")
  notIn: [Int] @cost(weight: "10")
  greaterThan: Int @cost(weight: "10")
  notGreaterThan: Int @cost(weight: "10")
  greaterThanOrEqualTo: Int @cost(weight: "10")
  notGreaterThanOrEqualTo: Int @cost(weight: "10")
  lessThan: Int @cost(weight: "10")
  notLessThan: Int @cost(weight: "10")
  lessThanOrEqualTo: Int @cost(weight: "10")
  notLessThanOrEqualTo: Int @cost(weight: "10")
}

input NumerationPropositionInput {
  and: [NumerationPropositionInput!]
  or: [NumerationPropositionInput!]
  prefix: StringPropositionInput
  mainNumber: StringPropositionInput
  suffix: StringPropositionInput
}

input OpticalDataPropositionInput {
  and: [OpticalDataPropositionInput!]
  or: [OpticalDataPropositionInput!]
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
  id: UuidPropositionInput
  nearnormalHemisphericalSolarReflectances: FloatsPropositionInput
  nearnormalHemisphericalSolarTransmittances: FloatsPropositionInput
  nearnormalHemisphericalVisibleReflectances: FloatsPropositionInput
  nearnormalHemisphericalVisibleTransmittances: FloatsPropositionInput
  infraredEmittances: FloatsPropositionInput
  colorRenderingIndices: FloatsPropositionInput
  cielabColors: ListFilterInputTypeOfCielabColorPropositionInput
}

input OpticalDataSortInput {
  locale: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  componentId: SortEnumType @cost(weight: "10")
  creatorId: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
  appliedMethod: AppliedMethodSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
}

input PhotovoltaicDataPropositionInput {
  and: [PhotovoltaicDataPropositionInput!]
  or: [PhotovoltaicDataPropositionInput!]
  locale: StringPropositionInput
  name: StringPropositionInput
  description: StringPropositionInput
  componentId: UuidPropositionInput
  creatorId: UuidPropositionInput
  createdAt: DateTimePropositionInput
  appliedMethod: AppliedMethodPropositionInput
  approvals: ListFilterInputTypeOfDataApprovalPropositionInput
  resources: ListGetHttpsResourceFilterTypePropositionInput
  warnings: StringsPropositionInput
  id: UuidPropositionInput
}

input PhotovoltaicDataSortInput {
  locale: SortEnumType @cost(weight: "10")
  name: SortEnumType @cost(weight: "10")
  description: SortEnumType @cost(weight: "10")
  componentId: SortEnumType @cost(weight: "10")
  creatorId: SortEnumType @cost(weight: "10")
  createdAt: SortEnumType @cost(weight: "10")
  appliedMethod: AppliedMethodSortInput @cost(weight: "10")
  id: SortEnumType @cost(weight: "10")
}

input PublicationPropositionInput {
  and: [PublicationPropositionInput!]
  or: [PublicationPropositionInput!]
  authors: StringsPropositionInput
  "The Digital Object Identifier (DOI) is a very important persistent identifier for publications. It MUST be defined here if it is available for a publication."
  doi: StringPropositionInput
  "The website arXiv.org is a free and open-access archive for publications. The arXiv identifier can be used to define a publication."
  arXiv: StringPropositionInput
  "A Uniform Resource Name (URN) can be used to define a publication. TODO: Improve the regex pattern to further restrict the string."
  urn: StringPropositionInput
  "If a persistent identifiert like DOI is defined above, this webAdress can define a convenient web address to access the publication. However, if no persistent identifier exist, this web address is the only identifier of this publication. In this case, it is important to choose a web address with a high probability to persist long."
  webAddress: UriPropositionInput
  title: StringPropositionInput
  abstract: StringPropositionInput
  "Referenced section"
  section: StringPropositionInput
}

input RootGetHttpsResourceInput {
  appliedConversionMethod: ToTreeVertexAppliedConversionMethodInput
  archivedFilesMetaInformation: [FileMetaInformationInput!]!
  dataFormatId: Uuid!
  description: String!
  hashValue: String!
}

"`ISO 52022` is an example of the abbreviation of a standardizer and the main number of the identifier."
input StandardPropositionInput {
  and: [StandardPropositionInput!]
  or: [StandardPropositionInput!]
  "It is important to define the year in which the standard was issued because there can be relevant updates of one standard."
  year: NullableOfInt32PropositionInput
  numeration: NumerationPropositionInput
  standardizers: ListStandardizerPropositionInput
  locator: UriPropositionInput
  title: StringPropositionInput
  abstract: StringPropositionInput
  "The section of the standard to which the reference refers to."
  section: StringPropositionInput
}

input StandardizerPropositionInput {
  equalTo: Standardizer @cost(weight: "10")
  notEqualTo: Standardizer @cost(weight: "10")
  in: [Standardizer!] @cost(weight: "10")
  notIn: [Standardizer!] @cost(weight: "10")
}

input StringPropositionInput {
  and: [StringPropositionInput!]
  or: [StringPropositionInput!]
  equalTo: String @cost(weight: "10")
  notEqualTo: String @cost(weight: "10")
  contains: String @cost(weight: "20")
  doesNotContain: String @cost(weight: "20")
  in: [String] @cost(weight: "10")
  notIn: [String] @cost(weight: "10")
  startsWith: String @cost(weight: "20")
  doesNotStartWith: String @cost(weight: "20")
  endsWith: String @cost(weight: "20")
  doesNotEndWith: String @cost(weight: "20")
}

input StringsPropositionInput {
  all: StringPropositionInput @cost(weight: "10")
  none: StringPropositionInput @cost(weight: "10")
  some: StringPropositionInput @cost(weight: "10")
  any: Boolean @cost(weight: "10")
}

input ToTreeVertexAppliedConversionMethodInput {
  arguments: [NamedMethodArgumentInput!]!
  methodId: Uuid!
  sourceName: String!
}

input ToTreeVertexAppliedConversionMethodPropositionInput {
  and: [ToTreeVertexAppliedConversionMethodPropositionInput!]
  or: [ToTreeVertexAppliedConversionMethodPropositionInput!]
  methodId: UuidPropositionInput
  arguments: ListNamedMethodArgumentFilterTypePropositionInput
  sourceName: StringPropositionInput
}

input ToTreeVertexAppliedConversionMethodSortInput {
  methodId: SortEnumType @cost(weight: "10")
  sourceName: SortEnumType @cost(weight: "10")
}

input UpdateDatabaseInput {
  databaseId: Uuid!
  description: String!
  locator: Url!
  name: String!
}

input UriHostNameTypePropositionInput {
  equalTo: UriHostNameType @cost(weight: "10")
  notEqualTo: UriHostNameType @cost(weight: "10")
  in: [UriHostNameType!] @cost(weight: "10")
  notIn: [UriHostNameType!] @cost(weight: "10")
}

input UriPropositionInput {
  and: [UriPropositionInput!]
  or: [UriPropositionInput!]
  absolutePath: StringPropositionInput
  absoluteUri: StringPropositionInput
  localPath: StringPropositionInput
  authority: StringPropositionInput
  hostNameType: UriHostNameTypePropositionInput
  isDefaultPort: BooleanPropositionInput
  isFile: BooleanPropositionInput
  isLoopback: BooleanPropositionInput
  pathAndQuery: StringPropositionInput
  segments: StringsPropositionInput
  isUnc: BooleanPropositionInput
  host: StringPropositionInput
  port: Int32PropositionInput
  query: StringPropositionInput
  fragment: StringPropositionInput
  scheme: StringPropositionInput
  originalString: StringPropositionInput
  dnsSafeHost: StringPropositionInput
  idnHost: StringPropositionInput
  isAbsoluteUri: BooleanPropositionInput
  userEscaped: BooleanPropositionInput
  userInfo: StringPropositionInput
}

input UuidPropositionInput {
  equalTo: Uuid @cost(weight: "10")
  notEqualTo: Uuid @cost(weight: "10")
  in: [Uuid!] @cost(weight: "10")
  notIn: [Uuid!] @cost(weight: "10")
  greaterThan: Uuid @cost(weight: "10")
  notGreaterThan: Uuid @cost(weight: "10")
  greaterThanOrEqualTo: Uuid @cost(weight: "10")
  notGreaterThanOrEqualTo: Uuid @cost(weight: "10")
  lessThan: Uuid @cost(weight: "10")
  notLessThan: Uuid @cost(weight: "10")
  lessThanOrEqualTo: Uuid @cost(weight: "10")
  notLessThanOrEqualTo: Uuid @cost(weight: "10")
}

"Defines when a policy shall be executed."
enum ApplyPolicy {
  "Before the resolver was executed."
  BEFORE_RESOLVER
  "After the resolver was executed."
  AFTER_RESOLVER
  "The policy is applied in the validation step before the execution."
  VALIDATION
}

enum CreateCalorimetricDataErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum CreateGeometricDataErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum CreateGetHttpsResourceErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum CreateHygrothermalDataErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum CreateOpticalDataErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum CreatePhotovoltaicDataErrorCode {
  UNKNOWN
  UNAUTHORIZED
}

enum DataKind {
  CALORIMETRIC_DATA
  HYGROTHERMAL_DATA
  OPTICAL_DATA
  PHOTOVOLTAIC_DATA
  GEOMETRIC_DATA
}

enum DatabaseVerificationState {
  PENDING
  VERIFIED
}

enum SortEnumType {
  ASC
  DESC
}

enum Standardizer {
  AERC
  AGI
  ASHRAE
  BREEAM
  BS
  BSI
  CEN
  CIE
  DGNB
  DIN
  DVWG
  IEC
  IES
  IFT
  ISO
  JIS
  LEED
  NFRC
  RIBA
  UL
  UNECE
  VDI
  VFF
  WELL
}

enum UpdateDatabaseErrorCode {
  UNKNOWN
  UNAUTHORIZED
  UNKNOWN_DATABASE
}

enum UriHostNameType {
  UNKNOWN
  BASIC
  DNS
  I_PV4
  I_PV6
}

"The purpose of the `cost` directive is to define a `weight` for GraphQL types, fields, and arguments. Static analysis can use these weights when calculating the overall cost of a query or response."
directive @cost("The `weight` argument defines what value to add to the overall cost for every appearance, or possible appearance, of a type, field, argument, etc." weight: String!) on SCALAR | OBJECT | FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM | INPUT_FIELD_DEFINITION

"The purpose of the `@listSize` directive is to either inform the static analysis about the size of returned lists (if that information is statically available), or to point the analysis to where to find that information."
directive @listSize("The `assumedSize` argument can be used to statically define the maximum length of a list returned by a field." assumedSize: Int "The `requireOneSlicingArgument` argument can be used to inform the static analysis that it should expect that exactly one of the defined slicing arguments is present in a query. If that is not the case (i.e., if none or multiple slicing arguments are present), the static analysis may throw an error." requireOneSlicingArgument: Boolean! = true "The `sizedFields` argument can be used to define that the value of the `assumedSize` argument or of a slicing argument does not affect the size of a list returned by a field itself, but that of a list returned by one of its sub-fields." sizedFields: [String!] "The `slicingArguments` argument can be used to define which of the field's arguments with numeric type are slicing arguments, so that their value determines the size of the list returned by that field. It may specify a list of multiple slicing arguments." slicingArguments: [String!]) on FIELD_DEFINITION

"The `@specifiedBy` directive is used within the type system definition language to provide a URL for specifying the behavior of custom scalar definitions."
directive @specifiedBy("The specifiedBy URL points to a human-readable specification. This field will only read a result for scalar types." url: String!) on SCALAR

scalar Any

"The `DateTime` scalar represents an ISO-8601 compliant date time type."
scalar DateTime @specifiedBy(url: "https:\/\/www.graphql-scalars.com\/date-time")

"BCP 47 compliant Language Tag string"
scalar Locale

scalar Url

scalar Uuid